// Code generated by counterfeiter. DO NOT EDIT.
package scraperfakes

import (
	"sync"

	"github.com/nimakaviani/github-contributors/pkg/models"
	"github.com/nimakaviani/github-contributors/pkg/scraper"
)

type FakeScraper struct {
	ActivitiesStub        func(string, int, int) ([]models.Activity, error)
	activitiesMutex       sync.RWMutex
	activitiesArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	activitiesReturns struct {
		result1 []models.Activity
		result2 error
	}
	activitiesReturnsOnCall map[int]struct {
		result1 []models.Activity
		result2 error
	}
	ContributorsStub        func(string, int) ([]models.User, error)
	contributorsMutex       sync.RWMutex
	contributorsArgsForCall []struct {
		arg1 string
		arg2 int
	}
	contributorsReturns struct {
		result1 []models.User
		result2 error
	}
	contributorsReturnsOnCall map[int]struct {
		result1 []models.User
		result2 error
	}
	FindStub        func(string) (string, error)
	findMutex       sync.RWMutex
	findArgsForCall []struct {
		arg1 string
	}
	findReturns struct {
		result1 string
		result2 error
	}
	findReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FindInRepoStub        func(string, string) (string, error)
	findInRepoMutex       sync.RWMutex
	findInRepoArgsForCall []struct {
		arg1 string
		arg2 string
	}
	findInRepoReturns struct {
		result1 string
		result2 error
	}
	findInRepoReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeScraper) Activities(arg1 string, arg2 int, arg3 int) ([]models.Activity, error) {
	fake.activitiesMutex.Lock()
	ret, specificReturn := fake.activitiesReturnsOnCall[len(fake.activitiesArgsForCall)]
	fake.activitiesArgsForCall = append(fake.activitiesArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ActivitiesStub
	fakeReturns := fake.activitiesReturns
	fake.recordInvocation("Activities", []interface{}{arg1, arg2, arg3})
	fake.activitiesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeScraper) ActivitiesCallCount() int {
	fake.activitiesMutex.RLock()
	defer fake.activitiesMutex.RUnlock()
	return len(fake.activitiesArgsForCall)
}

func (fake *FakeScraper) ActivitiesCalls(stub func(string, int, int) ([]models.Activity, error)) {
	fake.activitiesMutex.Lock()
	defer fake.activitiesMutex.Unlock()
	fake.ActivitiesStub = stub
}

func (fake *FakeScraper) ActivitiesArgsForCall(i int) (string, int, int) {
	fake.activitiesMutex.RLock()
	defer fake.activitiesMutex.RUnlock()
	argsForCall := fake.activitiesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeScraper) ActivitiesReturns(result1 []models.Activity, result2 error) {
	fake.activitiesMutex.Lock()
	defer fake.activitiesMutex.Unlock()
	fake.ActivitiesStub = nil
	fake.activitiesReturns = struct {
		result1 []models.Activity
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) ActivitiesReturnsOnCall(i int, result1 []models.Activity, result2 error) {
	fake.activitiesMutex.Lock()
	defer fake.activitiesMutex.Unlock()
	fake.ActivitiesStub = nil
	if fake.activitiesReturnsOnCall == nil {
		fake.activitiesReturnsOnCall = make(map[int]struct {
			result1 []models.Activity
			result2 error
		})
	}
	fake.activitiesReturnsOnCall[i] = struct {
		result1 []models.Activity
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) Contributors(arg1 string, arg2 int) ([]models.User, error) {
	fake.contributorsMutex.Lock()
	ret, specificReturn := fake.contributorsReturnsOnCall[len(fake.contributorsArgsForCall)]
	fake.contributorsArgsForCall = append(fake.contributorsArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.ContributorsStub
	fakeReturns := fake.contributorsReturns
	fake.recordInvocation("Contributors", []interface{}{arg1, arg2})
	fake.contributorsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeScraper) ContributorsCallCount() int {
	fake.contributorsMutex.RLock()
	defer fake.contributorsMutex.RUnlock()
	return len(fake.contributorsArgsForCall)
}

func (fake *FakeScraper) ContributorsCalls(stub func(string, int) ([]models.User, error)) {
	fake.contributorsMutex.Lock()
	defer fake.contributorsMutex.Unlock()
	fake.ContributorsStub = stub
}

func (fake *FakeScraper) ContributorsArgsForCall(i int) (string, int) {
	fake.contributorsMutex.RLock()
	defer fake.contributorsMutex.RUnlock()
	argsForCall := fake.contributorsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeScraper) ContributorsReturns(result1 []models.User, result2 error) {
	fake.contributorsMutex.Lock()
	defer fake.contributorsMutex.Unlock()
	fake.ContributorsStub = nil
	fake.contributorsReturns = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) ContributorsReturnsOnCall(i int, result1 []models.User, result2 error) {
	fake.contributorsMutex.Lock()
	defer fake.contributorsMutex.Unlock()
	fake.ContributorsStub = nil
	if fake.contributorsReturnsOnCall == nil {
		fake.contributorsReturnsOnCall = make(map[int]struct {
			result1 []models.User
			result2 error
		})
	}
	fake.contributorsReturnsOnCall[i] = struct {
		result1 []models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) Find(arg1 string) (string, error) {
	fake.findMutex.Lock()
	ret, specificReturn := fake.findReturnsOnCall[len(fake.findArgsForCall)]
	fake.findArgsForCall = append(fake.findArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindStub
	fakeReturns := fake.findReturns
	fake.recordInvocation("Find", []interface{}{arg1})
	fake.findMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeScraper) FindCallCount() int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return len(fake.findArgsForCall)
}

func (fake *FakeScraper) FindCalls(stub func(string) (string, error)) {
	fake.findMutex.Lock()
	defer fake.findMutex.Unlock()
	fake.FindStub = stub
}

func (fake *FakeScraper) FindArgsForCall(i int) string {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	argsForCall := fake.findArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeScraper) FindReturns(result1 string, result2 error) {
	fake.findMutex.Lock()
	defer fake.findMutex.Unlock()
	fake.FindStub = nil
	fake.findReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) FindReturnsOnCall(i int, result1 string, result2 error) {
	fake.findMutex.Lock()
	defer fake.findMutex.Unlock()
	fake.FindStub = nil
	if fake.findReturnsOnCall == nil {
		fake.findReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) FindInRepo(arg1 string, arg2 string) (string, error) {
	fake.findInRepoMutex.Lock()
	ret, specificReturn := fake.findInRepoReturnsOnCall[len(fake.findInRepoArgsForCall)]
	fake.findInRepoArgsForCall = append(fake.findInRepoArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.FindInRepoStub
	fakeReturns := fake.findInRepoReturns
	fake.recordInvocation("FindInRepo", []interface{}{arg1, arg2})
	fake.findInRepoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeScraper) FindInRepoCallCount() int {
	fake.findInRepoMutex.RLock()
	defer fake.findInRepoMutex.RUnlock()
	return len(fake.findInRepoArgsForCall)
}

func (fake *FakeScraper) FindInRepoCalls(stub func(string, string) (string, error)) {
	fake.findInRepoMutex.Lock()
	defer fake.findInRepoMutex.Unlock()
	fake.FindInRepoStub = stub
}

func (fake *FakeScraper) FindInRepoArgsForCall(i int) (string, string) {
	fake.findInRepoMutex.RLock()
	defer fake.findInRepoMutex.RUnlock()
	argsForCall := fake.findInRepoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeScraper) FindInRepoReturns(result1 string, result2 error) {
	fake.findInRepoMutex.Lock()
	defer fake.findInRepoMutex.Unlock()
	fake.FindInRepoStub = nil
	fake.findInRepoReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) FindInRepoReturnsOnCall(i int, result1 string, result2 error) {
	fake.findInRepoMutex.Lock()
	defer fake.findInRepoMutex.Unlock()
	fake.FindInRepoStub = nil
	if fake.findInRepoReturnsOnCall == nil {
		fake.findInRepoReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findInRepoReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeScraper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activitiesMutex.RLock()
	defer fake.activitiesMutex.RUnlock()
	fake.contributorsMutex.RLock()
	defer fake.contributorsMutex.RUnlock()
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	fake.findInRepoMutex.RLock()
	defer fake.findInRepoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeScraper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ scraper.Scraper = new(FakeScraper)
